# Copyright 2014 - Sean Donovan
# DNS Metadata Engine

from dnsclassify import *
from dnsentry import DNSClassifierEntry as DNSEntry
from assayrule import *
from pyretic.lib.corelib import *
from pyretic.lib.std import *
from pyretic.lib.query import *


class DNSMetadataEngineException(Exception):
    pass

class DNSMetadataEngine:
    def __init__(self):
        pass

    def update_rules(self):
        pass
    

class DNSMetadataEntry:
    def __init__(self, classifier, engine, rule ):
        self.classifier = classifier
        self.engine = engine
        self.rule = rule
        
        #register for all the callbacks necessary
        if self.rule.type == AssayRule.CLASSIFICATION:
            classifier.set_classification_callback(
                self.handle_classification_callback,
                self.rule.value)
        else:
            classifier.set_new_callback(self.handle_new_entry_callback)
            #classification change
            classifier.

    def handle_expiration_callback(self, addr, entry):
        #need to remove the rule that was generated by the particular DNSEntry
        self.rule.remove_rule(match(srcip=addr))

    def handle_new_entry_callback(self, addr, entry):
        if self.rule.type == AssayRule.CLASSIFICATION:
            if entry.classification == self.rule.value:
                self.rule.add_rule(match(srcip=addr))
        elif self.rule.type == AssayRule.AS:
            print "WE DON'T HANDLE AS RULES>"
            raise DNSMetadataEngineException("WE DON'T HANDLE AS RULES")
        elif self.rule.type == AssayRule.DNS_NAME:
            for name in entry.names:
                if name == self.rule.value:
                    self.rule.add_rule(match(srcip=addr))

    def handle_classification_callback(self, addr, entry):
        # This should only be registered for if you care about a particular 
        # class, so it's blindly adding a rule for the particular entry.
        self.rule.add_rule(match(srcip=addr))
        entry.register_timeout_callback(self.handle_expiration_callback)

    
